# -*- coding: utf-8 -*-
"""
Created on Tue Nov 21 15:58:36 2023

@author: ammosov_yam
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import hibpcalc.geomfunc as gf
import copy

def plot_grid(grid, r):
    """
    
    Plot 2D circle grid generated by create_disk_grid function.

    Parameters
    ----------
    grid : list of two lists of floats - [[x values], [y values]].
        List with x and y values.
    r : float
        Radius of a circle.

    Returns
    -------
    None.

    """

    # plot radius - red circle
    cx, cy = [], [] 
    for i in range(0, 51):
      t = 2.0 * np.pi * i / 50.0
      cx.append(r * np.cos(t))
      cy.append(r * np.sin(t))
    plt.plot (cx, cy, linewidth=2.0, color='r' )
    
    # plot grid - blue dots
    plt.plot(grid[0][:], grid[1][:], 'bs' )
    
    # matplotlib parameters
    plt.xlabel('<---X--->')
    plt.ylabel('<---Y--->')
    plt.title('Grid points in circle')
    plt.grid(True)
    plt.axis('equal')
    plt.show(block=False)

def create_disk_grid(c, r, n):
    """
    
    Creates 2D rectangle grid of points inside circle with raidus r.

    Parameters
    ----------
    c : list of float
        Circle central dot. Example: c = [0, 0].
    r : float
        Radius of a circle.
    n : int
        Amount of dots along vertical and horizontal diameters of rectangle grid.
        Odd values are preferred.

    Returns
    -------
    grid : list of two lists of floats - [[x values], [y values]]
        list with x and y values of grid.

    """
    
    # only 1 central dot
    if n == 1:
        return [[c[0]], [c[1]]]
    
    grid = [[],[]]
    
    # set grid boundary points
    left_point  = c[0] - r
    right_point = c[0] + r
    down_point  = c[1] - r
    up_point    = c[1] + r
    
    # create horizontal and vertical diameters of rectangle grid
    x = np.linspace(left_point, right_point, int(n))
    y = np.linspace(down_point, up_point, int(n))
    
    # create full rectangle grid of points
    X, Y = np.meshgrid(x, y)
    positions = np.vstack([X.ravel(), Y.ravel()])
    
    # take points, which inside the circle with radius r
    for i in range(len(positions[0])):
        point = [positions[0][i], positions[1][i]]
        if np.linalg.norm([c, point]) <= r:
            grid[0].append(point[0])
            grid[1].append(point[1])
    
    return grid

def profile_function(x, y, x0, y0, sigma):
    return np.exp(-((x - x0)**2 + (y - y0)**2) / (2 * sigma**2))

def create_3d_plot(radius, profile_func):
    # Define the grid
    x = np.linspace(-radius, radius, 100)
    y = np.linspace(-radius, radius, 100)
    X, Y = np.meshgrid(x, y)

    # Compute the profile function at each point
    Z = profile_func(X, Y, 0, 0, 1)

    # Plot the 3D surface
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.plot_surface(X, Y, Z)

    # Set labels and show the plot
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    plt.show()

def create_3d_plot_my(c, r, grid):

    # Plot the 3D surface
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    # ax.plot_surface(grid[0], grid[1], grid[2])
    ax.plot_trisurf(grid[0], grid[1], grid[2], linewidth=1, alpha=0.5, color='green')
    
    # ax.scatter(grid[0], grid[1], color='blue')
    ax.scatter(grid[0], grid[1], grid[2], color='red')
    
    # plot radius - red circle
    cx, cy = [], [] 
    for i in range(0, 51):
      t = 2.0 * np.pi * i / 50.0
      cx.append(r * np.cos(t) + c[0])
      cy.append(r * np.sin(t) + c[1])
    ax.plot(cx, cy, linewidth=2.0, color='blue' )
    
    # Set labels and show the plot
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    plt.show()

def create_disk_grid_gauss(c0, r, n, profile):
    """
    
    Creates 2D rectangle grid of points inside circle with raidus r.

    Parameters
    ----------
    c : list of float
        Circle central dot. Example: c = [0, 0].
    r : float
        Radius of a circle.
    n : int
        Amount of dots along vertical and horizontal diameters of rectangle grid.
        Odd values are preferred.
    profile : function
        Function with given distribution.    
        For example Gauss function.
        
    Returns
    -------
    grid : list of three lists of floats - [[x values], [y values], [z values]]
        list with x, y values of grid and z values of profile function.
        Example: X and Y in meters, Z - values of Gauss function at [X, Y] point.

    """
    
    c = [0, 0] # create grid for [0, 0] point and then add c0 values

    # only 1 central dot
    if n == 1:
        return [[c[0]], [c[1]], [0]]

    grid = [[],[],[]]
    
    # set grid boundary points
    left_point  = c[0] - r
    right_point = c[0] + r
    down_point  = c[1] - r
    up_point    = c[1] + r
    
    # create horizontal and vertical diameters of rectangle grid
    x = np.linspace(left_point, right_point, int(n))
    y = np.linspace(down_point, up_point, int(n))
    
    # create rectangle grid of points
    X, Y = np.meshgrid(x, y)
    # Compute the profile function at each point
    sx=sy=0.003
    Z = profile(X, Y, c[0], c[1], sx, sy)
    positions = np.vstack([X.ravel(), Y.ravel(), Z.ravel()])
    
    # take points of rectangle grid, which inside the circle with radius r
    for i in range(len(positions[0])):
        p = [positions[0][i], positions[1][i], positions[2][i]]
        if (p[0]-c[0])**2 + (p[1]-c[1])**2 <= r**2:
            grid[0].append(p[0]+c0[0]) # Z axis
            grid[1].append(p[1]+c0[1]) # Y axis
            grid[2].append(p[2]) # Z axis - profile func values
    
    return grid

def fatbeam_set_new_RV0s(tr, n_filaments_xy, n_gamma, skip_center_traj, d_beam, foc_len):
    
    tr_rots = []
    tr_fat_buff_list = [] # list contains trajectories with new RV0
    drad = np.pi/180. # degrees converting constant
    r0 = tr.RV0[0, :3]
    v0_abs = np.linalg.norm(tr.RV0[0, 3:])
    
    for i in range(n_filaments_xy):
    # skip center traj
        if abs(i - (n_filaments_xy-1)/2) < 1e-6 and skip_center_traj:
            continue
        
        # beam convergence angle
        alpha_conv = np.arctan((i - (n_filaments_xy-1)/2) *
                           (d_beam/(n_filaments_xy-1)) / foc_len)
        
        # set coords and velocity at the center of coord system
        x = 0.0
        y = -(i - (n_filaments_xy-1)/2) * (d_beam/(n_filaments_xy-1))
        z = 0.0
        r = np.array([x, y, z])
        # print('XY filament number = {}'.format(i+1))
        
        v0 = v0_abs * np.array([-np.cos(alpha_conv),
                            np.sin(alpha_conv), 0.])
        
        for gamma in np.arange(np.pi/n_gamma, 2*np.pi, np.pi/n_gamma):
            # convert gamma to angles
            gamma = gamma/drad

            # create filaments new starting positions by rotating and shifting
            r_rot = gf.rotate(r, axis=(1, 0, 0), deg=gamma)
            r_rot = gf.rotate(r_rot, axis=(0, 0, 1), deg=tr.alpha)
            r_rot = gf.rotate(r_rot, axis=(0, 1, 0), deg=tr.beta)
            r_rot += r0
            v_rot = gf.rotate(v0, axis=(1, 0, 0), deg=gamma)
            v_rot = gf.rotate(v_rot, axis=(0, 0, 1), deg=tr.alpha)
            v_rot = gf.rotate(v_rot, axis=(0, 1, 0), deg=tr.beta)
            tr_fat = copy.deepcopy(tr)
            tr_fat.RV0[0, :] = np.hstack([r_rot, v_rot])
            tr_rots.append(r_rot)
            tr_fat_buff_list.append(tr_fat)
            
            if abs(y) < 1e-6:
                break
    return tr_fat_buff_list, tr_rots

def gaus2d(x=0, y=0, mx=0, my=0, sx=0.003, sy=0.003, a=1, pad=0):
    return a * np.exp(-((x - mx)**2. / (2. * sx**2.) + (y - my)**2. / (2. * sy**2.))) + pad

def fatbeam_set_new_RV0s2(tr, n_filaments_xy, n_gamma, skip_center_traj, d_beam, foc_len):
    tr_rots = []
    tr_fat_buff_list = [] # list contains trajectories with new RV0
    r0 = tr.RV0[0, :3]
    v0_abs = np.linalg.norm(tr.RV0[0, 3:])
    n = 7 # Amount of dots along vertical and horizontal diameters of rectangle grid.
    
    grid = create_disk_grid_gauss([0, 0], d_beam/2., n, gaus2d)
    
    n_filaments_xy = len(grid[0])
    
    for i in range(n_filaments_xy):
    # skip center traj
        # if abs(i - (n_filaments_xy-1)/2) < 1e-6 and skip_center_traj:
        #     continue
        
        # beam convergence angle
        alpha_conv = np.arctan((i - (n_filaments_xy-1)/2) *
                            (d_beam/(n_filaments_xy-1)) / foc_len)
        # alpha_conv = 0
        
        # set coords and velocity at the center of coord system
        # x = 0.0
        # y = -(i - (n_filaments_xy-1)/2) * (d_beam/(n_filaments_xy-1))
        # z = 0.0
        
        r = [grid[0][i], grid[1][i], 0]
        
        v0 = v0_abs * np.array([-np.cos(alpha_conv),
                            np.sin(alpha_conv), 0.])
       
        # create filaments new starting positions by rotating and shifting
        r_rot = gf.rotate(np.array(r), axis=(1, 0, 0), deg=90)
        r_rot = gf.rotate(r_rot, axis=(0, 0, 1), deg=tr.alpha+90)
        r_rot = gf.rotate(r_rot, axis=(0, 1, 0), deg=tr.beta)
        r_rot += r0
        v_rot = gf.rotate(v0, axis=(1, 0, 0), deg=90)
        v_rot = gf.rotate(v_rot, axis=(0, 0, 1), deg=tr.alpha)
        v_rot = gf.rotate(v_rot, axis=(0, 1, 0), deg=tr.beta)
        
        tr_fat = copy.deepcopy(tr)
        tr_fat.I0 = grid[2][i]
        tr_fat.RV0[0, :] = np.hstack([r_rot, v_rot])
        tr_rots.append(r_rot)
        tr_fat_buff_list.append(tr_fat)
        
        # if abs(y) < 1e-6:
        #     break
        
    return tr_fat_buff_list, tr_rots


def rv_trlist(tr):
    tr_rv = []
    for elem in tr:
        tr_rv.append(elem.RV0)
    # print(tr_rv)
    return tr_rv

def isequal_arr(arr1, arr2):
    if (arr1[0][0]==arr2[0][0]) and (arr1[0][1]==arr2[0][1]) and (arr1[0][2]==arr2[0][2]):
        return True
    else:
        return False

if __name__ == '__main__':
    
    c = [0, 0] # Coordinates of central dot of a circle
    r = 0.01 # radius of a circle [cm]
    n = 7 # Amount of dots along vertical and horizontal diameters of rectangle grid.
    
    # grid = create_disk_grid(c, r, n)
    # plot_grid(grid, r)
    
    def gaus2d(x=0, y=0, mx=0, my=0, sx=1, sy=1, a=1, pad=0):
        return a * np.exp(-((x - mx)**2. / (2. * sx**2.) + (y - my)**2. / (2. * sy**2.))) + pad
    
    def gaus1d(x=0, mx=0, s=1, a=1, pad=0):
        return a * np.exp(-((x - mx)**2. / (2. * s**2.))) + pad
    
    # Main plot 3D Hat
    # grid2 = create_disk_grid_gauss(c, r, n, gaus2d)
    # create_3d_plot_my(c, r, grid2)
    
    # 1D Gauss plot
    # fig, ax = plt.subplots()
    # x = np.linspace(-100, 100, 2000)
    # ax.plot(x, gaus1d(x))
    
    n_filaments_xy = 5
    n_gamma = 2
    skip_center_traj = False
    d_beam = 0.02
    foc_len = 50
    
    tr_fat_buff_list1, rots = fatbeam_set_new_RV0s(traj_list_optimized[0], n_filaments_xy, n_gamma, skip_center_traj, d_beam, foc_len)
    tr_fat_buff_list2, rots2 = fatbeam_set_new_RV0s2(traj_list_optimized[0], n_filaments_xy, n_gamma, skip_center_traj, d_beam, foc_len)

    fig = plt.figure()
    ax = fig.add_subplot(projection='3d')
    
    for r in rots:
        ax.scatter(r[0], r[1], r[2], c='r', s=100) 
    for r in rots2:
        ax.scatter(r[0], r[1], r[2], c='b')
        
    ax.axis('equal')
    
    traj1 = rv_trlist(tr_fat_buff_list1)
    traj2 = rv_trlist(tr_fat_buff_list2)
    # print(traj1, '\n', traj2)
    
    for i in traj1:
        for j in traj2:
            if isequal_arr(i, j):
                print(i[0][3:], '\n', j[0][3:], '\n\n')
    